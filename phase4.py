"""
phase4.py
=========
Phase 4: Pre-writing analyses and figure generation for the perpetuals paper.

Run from the project root directory.  All outputs go to output/Phase 4/.

DATA analyses exported
----------------------
  DATA-1  output/Phase 4/Cross-Correlation/<ASSET>_cross_correlation.csv
          output/Phase 4/Cross-Correlation/cross_correlation_summary.csv
  DATA-2  output/Phase 4/Price-Tracking/price_tracking_summary.csv
  DATA-3  output/Phase 4/Volume-Ratios/volume_ratios.csv
  DATA-4  output/Phase 4/Funding-Rate-Analysis/funding_rate_summary.csv
          output/Phase 4/Funding-Rate-Analysis/funding_rate_snapshot_17assets.csv
  DATA-5  output/Phase 4/Tables/table1_descriptive_stats.csv

Paper figures (PNG 300 dpi + PDF)
----------------------------------
  output/Phase 4/Figures/figure1_volume_time_series.{png,pdf}
  output/Phase 4/Figures/figure2_tscore_heatmap.{png,pdf}
  output/Phase 4/Figures/figure3_event_study.{png,pdf}
  output/Phase 4/Figures/figure4_cross_correlation.{png,pdf}
  output/Phase 4/Figures/figure5_price_tracking.{png,pdf}
  output/Phase 4/Figures/figure6_breadth_timeline.{png,pdf}
  output/Phase 4/Figures/figure7_funding_rates.{png,pdf}
  output/Phase 4/Figures/figure8_volume_ratios.{png,pdf}

Note: T-test CSVs read from output/Phase 2B/Daily Volume Analysis/ —
those are generated by phase2B.ipynb and are not reproduced here.
"""

import warnings
warnings.filterwarnings("ignore")

from pathlib import Path
import numpy as np
import pandas as pd

import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import matplotlib.ticker as mticker
from matplotlib.colors import TwoSlopeNorm
from matplotlib.patches import Patch

# ── Output directory ──────────────────────────────────────────────────────────
PHASE4_DIR = Path("output/Phase 4")

# ── Input directories ─────────────────────────────────────────────────────────
PHASE_1A_DIR  = Path("output/Phase 1A")
PHASE_1B_DIR  = Path("output/Phase 1B")
PHASE_2B_DIR  = Path("output/Phase 2B")   # t-test CSVs live here (phase2B.ipynb output)
DATES_DIR     = Path("Paper/Dates")
MARKET_SNAP   = PHASE_1A_DIR / "market_snapshot.csv"

# ── Analysis window ───────────────────────────────────────────────────────────
START_DATE = "2025-07-01"
END_DATE   = "2026-02-15"
START_TS   = pd.Timestamp(START_DATE)
END_TS     = pd.Timestamp(END_DATE)

# ── Asset universe ────────────────────────────────────────────────────────────
ASSET_TYPES = {
    "BTC":         "Crypto Coin",
    "ETH":         "Crypto Coin",
    "SOL":         "Crypto Coin",
    "LINK":        "Crypto Coin",
    "ADA":         "Crypto Coin",
    "NVDA":        "Traditional Equity",
    "TSLA":        "Traditional Equity",
    "AAPL":        "Traditional Equity",
    "MSFT":        "Traditional Equity",
    "GOOGL":       "Traditional Equity",
    "META":        "Traditional Equity",
    "AMZN":        "Traditional Equity",
    "COIN":        "Traditional Equity",
    "Gold":        "Traditional Commodity",
    "Silver":      "Traditional Commodity",
    "Oil":         "Traditional Commodity",
    "Natural Gas": "Traditional Commodity",
}

# Mapping from Phase 1B Excel stem → market_snapshot Name(s)
# Commodities appear under different tickers in the snapshot
SNAPSHOT_NAMES = {
    "Gold":        ["GOLD"],
    "Silver":      ["SILVER"],
    "Oil":         ["OIL", "CL", "USOIL"],
    "Natural Gas": ["NATGAS"],
}

TYPE_ORDER  = ["Crypto Coin", "Traditional Equity", "Traditional Commodity"]
TYPE_LABELS = {
    "Crypto Coin":           "Crypto Coins",
    "Traditional Equity":    "Tokenized Equities",
    "Traditional Commodity": "Tokenized Commodities",
}

# Key macro events for Figure 3
EVENTS = [
    ("BoJ Carry Unwind",         "2024-08-05", ["BTC", "ETH", "SOL", "LINK", "ADA"]),
    ("DeepSeek AI Shock",        "2025-01-27", ["BTC", "ETH", "SOL", "LINK", "ADA"]),
    ("Crypto Reserve Announce.", "2025-03-02", ["BTC", "ETH", "SOL", "LINK", "ADA"]),
    ("Trump 100% Tariffs",       "2025-10-10", list(ASSET_TYPES.keys())),
    ("FOMC + Earnings Peak",     "2026-01-29", list(ASSET_TYPES.keys())),
    ("Warsh Shock",              "2026-01-30", list(ASSET_TYPES.keys())),
]

# ── Matplotlib style ──────────────────────────────────────────────────────────
plt.rcParams.update({
    "font.family":       "serif",
    "font.size":         10,
    "axes.titlesize":    11,
    "axes.labelsize":    10,
    "xtick.labelsize":   9,
    "ytick.labelsize":   9,
    "legend.fontsize":   9,
    "figure.dpi":        300,
    "savefig.dpi":       300,
    "savefig.bbox":      "tight",
    "axes.spines.top":   False,
    "axes.spines.right": False,
})

DEFI_COLOR    = "#2171b5"   # steel blue
TRADFI_COLOR  = "#cb181d"   # red
NEUTRAL_COLOR = "#636363"
COMMODITY_COLOR = "#41ab5d" # green


# =============================================================================
# SHARED HELPERS
# =============================================================================

def load_assets():
    """Load all 17 Phase 1B Excel files. Returns dict: asset_name → {df, asset_type}."""
    assets = {}
    for asset_type_dir in PHASE_1B_DIR.iterdir():
        if not asset_type_dir.is_dir():
            continue
        for xlsx in asset_type_dir.glob("*.xlsx"):
            name = xlsx.stem
            if name not in ASSET_TYPES:
                continue
            df = pd.read_excel(xlsx)
            df["time"] = pd.to_datetime(df["time"])
            df = df.sort_values("time").reset_index(drop=True)
            assets[name] = {"df": df, "asset_type": ASSET_TYPES[name]}
            print(f"  Loaded {name:15s} ({ASSET_TYPES[name]:<25s}) "
                  f"{len(df):>5} rows  "
                  f"[{df['time'].min().date()} → {df['time'].max().date()}]")
    return assets


def window_filter(df, start=None, end=None):
    """Return rows within [start, end] inclusive."""
    mask = pd.Series(True, index=df.index)
    if start:
        mask &= df["time"] >= start
    if end:
        mask &= df["time"] <= end
    return df[mask].copy()


def overlap_rows(df):
    """Rows where both DeFi and TradFi volumes are non-NaN and non-zero."""
    return df[
        df["defi_notional_volume"].notna()  & (df["defi_notional_volume"]  > 0) &
        df["tradfi_notional_volume"].notna() & (df["tradfi_notional_volume"] > 0)
    ]


def price_overlap_rows(df):
    """Rows where both DeFi and TradFi close prices are non-NaN."""
    return df[df["defi_close"].notna() & df["tradfi_close"].notna()]


def load_ttest_csvs():
    """Load t-test CSVs from Phase 2B (generated by phase2B.ipynb)."""
    ttest_dir = PHASE_2B_DIR / "Daily Volume Analysis"
    data = {}
    for csv_path in ttest_dir.glob("*_daily_volume_ttest.csv"):
        name = csv_path.stem.replace("_daily_volume_ttest", "")
        if name not in ASSET_TYPES:
            continue
        df = pd.read_csv(csv_path, parse_dates=["date"])
        df = df.sort_values("date").reset_index(drop=True)
        data[name] = df
    return data


def save_fig(fig, name):
    """Save figure as PNG and PDF to the Phase 4 Figures directory."""
    figures_dir = PHASE4_DIR / "Figures"
    figures_dir.mkdir(parents=True, exist_ok=True)
    for ext in ("png", "pdf"):
        fig.savefig(figures_dir / f"{name}.{ext}")
    print(f"  → Saved {name}.{{png,pdf}}")
    plt.close(fig)


# =============================================================================
# DATA-1  Cross-Correlation
# =============================================================================

def run_cross_correlation(assets):
    """Compute lag-k Pearson correlations between DeFi and TradFi volume."""
    out_dir = PHASE4_DIR / "Cross-Correlation"
    out_dir.mkdir(parents=True, exist_ok=True)

    lags = list(range(-7, 8))   # -7 … +7
    summary_rows = []

    for name, info in sorted(assets.items()):
        df = overlap_rows(info["df"])

        if len(df) < 15:
            print(f"  [SKIP] {name}: only {len(df)} overlapping rows")
            continue

        defi   = df["defi_notional_volume"].values.astype(float)
        tradfi = df["tradfi_notional_volume"].values.astype(float)

        lag_rows = []
        for lag in lags:
            if lag < 0:
                d, t = defi[:lag], tradfi[-lag:]
            elif lag > 0:
                d, t = defi[lag:], tradfi[:-lag]
            else:
                d, t = defi, tradfi

            if len(d) >= 5:
                corr = float(np.corrcoef(d, t)[0, 1])
                n    = len(d)
            else:
                corr, n = np.nan, len(d)

            lag_rows.append({"lag": lag, "correlation": round(corr, 6), "n": n})

        lag_df = pd.DataFrame(lag_rows)
        lag_df.to_csv(out_dir / f"{name}_cross_correlation.csv", index=False)

        valid = lag_df.dropna(subset=["correlation"])
        if len(valid):
            peak_idx  = valid["correlation"].abs().idxmax()
            peak_lag  = int(valid.loc[peak_idx, "lag"])
            peak_corr = float(valid.loc[peak_idx, "correlation"])
            lag0_corr = (float(valid[valid["lag"] == 0]["correlation"].values[0])
                         if 0 in valid["lag"].values else np.nan)
        else:
            peak_lag = peak_corr = lag0_corr = np.nan

        summary_rows.append({
            "asset":      name,
            "asset_type": info["asset_type"],
            "n_overlap":  len(df),
            "peak_lag":   peak_lag,
            "peak_corr":  round(peak_corr, 4) if not np.isnan(float(peak_lag if peak_lag is not np.nan else np.nan)) else np.nan,
            "corr_lag_0": round(lag0_corr, 4) if not np.isnan(float(lag0_corr if lag0_corr is not np.nan else np.nan)) else np.nan,
        })
        print(f"  {name:15s}  peak lag={peak_lag!s:>3}  "
              f"r={peak_corr!s:.{3 if isinstance(peak_corr, float) else 0}}  "
              f"r(0)={lag0_corr!s:.{3 if isinstance(lag0_corr, float) else 0}}  n={len(df)}")

    summary_df = pd.DataFrame(summary_rows)
    summary_path = out_dir / "cross_correlation_summary.csv"
    summary_df.to_csv(summary_path, index=False)
    print(f"\n  → Saved: {summary_path}")
    return summary_df


# =============================================================================
# DATA-2  Price Tracking
# =============================================================================

def run_price_tracking(assets):
    """Compute price correlation, tracking error, and mean pct deviation."""
    out_dir = PHASE4_DIR / "Price-Tracking"
    out_dir.mkdir(parents=True, exist_ok=True)

    rows = []
    for name, info in sorted(assets.items()):
        df = price_overlap_rows(info["df"])

        if len(df) < 5:
            print(f"  [SKIP] {name}: only {len(df)} price overlap rows")
            continue

        defi_p   = df["defi_close"].astype(float)
        tradfi_p = df["tradfi_close"].astype(float)

        corr           = float(defi_p.corr(tradfi_p))
        diff           = defi_p - tradfi_p
        tracking_error = float(diff.std())
        pct_diff       = (diff / tradfi_p) * 100
        avg_pct_diff   = float(pct_diff.mean())
        abs_pct_diff   = float(pct_diff.abs().mean())
        max_pct_diff   = float(pct_diff.abs().max())

        rows.append({
            "asset":              name,
            "asset_type":         info["asset_type"],
            "n_days":             len(df),
            "date_start":         df["time"].min().date().isoformat(),
            "date_end":           df["time"].max().date().isoformat(),
            "price_corr":         round(corr, 6),
            "tracking_error_usd": round(tracking_error, 4),
            "avg_pct_diff":       round(avg_pct_diff, 4),
            "mean_abs_pct_diff":  round(abs_pct_diff, 4),
            "max_abs_pct_diff":   round(max_pct_diff, 4),
        })
        print(f"  {name:15s}  ρ={corr:.4f}  TE=${tracking_error:,.2f}  "
              f"avg_diff={avg_pct_diff:+.2f}%  n={len(df)}")

    out_df = pd.DataFrame(rows)
    out_path = out_dir / "price_tracking_summary.csv"
    out_df.to_csv(out_path, index=False)
    print(f"\n  → Saved: {out_path}")
    return out_df


# =============================================================================
# DATA-3  Volume Ratios
# =============================================================================

def run_volume_ratios(assets):
    """Compute TradFi/DeFi mean volume ratios for full period and analysis window."""
    out_dir = PHASE4_DIR / "Volume-Ratios"
    out_dir.mkdir(parents=True, exist_ok=True)

    rows = []
    for name, info in sorted(assets.items()):
        df_full = overlap_rows(info["df"])
        df_win  = overlap_rows(window_filter(info["df"], START_DATE, END_DATE))

        def ratio_stats(d):
            if len(d) == 0:
                return dict(n=0, defi_mean=np.nan, tradfi_mean=np.nan,
                            ratio=np.nan, defi_median=np.nan, tradfi_median=np.nan)
            dm = float(d["defi_notional_volume"].mean())
            tm = float(d["tradfi_notional_volume"].mean())
            return dict(
                n             = len(d),
                defi_mean     = round(dm, 2),
                tradfi_mean   = round(tm, 2),
                ratio         = round(tm / dm, 4) if dm > 0 else np.nan,
                defi_median   = round(float(d["defi_notional_volume"].median()), 2),
                tradfi_median = round(float(d["tradfi_notional_volume"].median()), 2),
            )

        full = ratio_stats(df_full)
        win  = ratio_stats(df_win)

        rows.append({
            "asset":                  name,
            "asset_type":             info["asset_type"],
            "full_n_overlap":         full["n"],
            "full_defi_mean_vol":     full["defi_mean"],
            "full_tradfi_mean_vol":   full["tradfi_mean"],
            "full_tradfi_defi_ratio": full["ratio"],
            "win_n_overlap":          win["n"],
            "win_defi_mean_vol":      win["defi_mean"],
            "win_tradfi_mean_vol":    win["tradfi_mean"],
            "win_tradfi_defi_ratio":  win["ratio"],
        })
        print(f"  {name:15s}  full_ratio={str(full['ratio']):>8}x  "
              f"win_ratio={str(win['ratio']):>8}x  "
              f"(full n={full['n']}, win n={win['n']})")

    out_df = pd.DataFrame(rows).sort_values(["asset_type", "asset"])
    out_path = out_dir / "volume_ratios.csv"
    out_df.to_csv(out_path, index=False)
    print(f"\n  → Saved: {out_path}")
    return out_df


# =============================================================================
# DATA-4  Funding Rate Analysis
# =============================================================================

def run_funding_rate_analysis():
    """Summarize snapshot funding rates from Phase 1A market_snapshot.csv."""
    out_dir = PHASE4_DIR / "Funding-Rate-Analysis"
    out_dir.mkdir(parents=True, exist_ok=True)

    snap = pd.read_csv(MARKET_SNAP)
    snap.columns = snap.columns.str.strip()
    snap["Funding Rate"]  = pd.to_numeric(snap["Funding Rate"],  errors="coerce")
    snap["Price"]         = pd.to_numeric(snap["Price"],         errors="coerce")
    snap["Volume (24h)"]  = pd.to_numeric(snap["Volume (24h)"],  errors="coerce")
    snap["Open Interest"] = pd.to_numeric(snap["Open Interest"], errors="coerce")

    # Build reverse lookup: snapshot Name → canonical asset name
    reverse_map = {}
    for canonical, snap_names in SNAPSHOT_NAMES.items():
        for sn in snap_names:
            reverse_map[sn] = canonical
    for a in ASSET_TYPES:
        if a not in SNAPSHOT_NAMES:
            reverse_map[a] = a

    snap["canonical"] = snap["Name"].map(reverse_map)
    snap_17 = snap[snap["canonical"].notna()].copy()
    snap_17["Asset Type"] = snap_17["canonical"].map(ASSET_TYPES)

    snap_17.to_csv(out_dir / "funding_rate_snapshot_17assets.csv", index=False)

    rows = []
    for name, group in snap_17.groupby("canonical"):
        fr = group["Funding Rate"].dropna()
        rows.append({
            "asset":                  name,
            "asset_type":             ASSET_TYPES[name],
            "n_dex_entries":          len(group),
            "funding_mean":           round(float(fr.mean()), 8) if len(fr) else np.nan,
            "funding_std":            round(float(fr.std()),  8) if len(fr) > 1 else np.nan,
            "funding_min":            round(float(fr.min()),  8) if len(fr) else np.nan,
            "funding_max":            round(float(fr.max()),  8) if len(fr) else np.nan,
            # mean 8-h rate × 3 payments/day × 365 days × 100
            "funding_annualised_pct": round(float(fr.mean()) * 3 * 365 * 100, 4) if len(fr) else np.nan,
            "price_usd":              round(float(group["Price"].mean()), 4) if group["Price"].notna().any() else np.nan,
            "volume_24h_usd":         round(float(group["Volume (24h)"].sum()), 0) if group["Volume (24h)"].notna().any() else np.nan,
            "open_interest_usd":      round(float(group["Open Interest"].sum()), 0) if group["Open Interest"].notna().any() else np.nan,
        })
        fr_val = rows[-1]["funding_mean"]
        ann    = rows[-1]["funding_annualised_pct"]
        print(f"  {name:15s}  funding_mean={str(fr_val):>12}  "
              f"annualised={str(ann):>8}%  n_dex={rows[-1]['n_dex_entries']}")

    summary = pd.DataFrame(rows).sort_values(["asset_type", "asset"])
    out_path = out_dir / "funding_rate_summary.csv"
    summary.to_csv(out_path, index=False)
    print(f"\n  → Saved: {out_path}")
    return summary


# =============================================================================
# DATA-5  Table 1 Descriptive Statistics
# =============================================================================

def run_table1(assets):
    """Build Table 1: per-asset descriptive statistics for DeFi and TradFi volumes."""
    out_dir = PHASE4_DIR / "Tables"
    out_dir.mkdir(parents=True, exist_ok=True)

    rows = []
    for name, info in sorted(assets.items()):
        df_full = info["df"]
        df_win  = window_filter(df_full, START_DATE, END_DATE)

        for side, vol_col in [("DeFi", "defi_notional_volume"), ("TradFi", "tradfi_notional_volume")]:
            full_valid = df_full[df_full[vol_col].notna() & (df_full[vol_col] > 0)][vol_col]
            win_valid  = df_win [df_win [vol_col].notna() & (df_win [vol_col] > 0)][vol_col]

            if len(full_valid) == 0:
                inception = np.nan
                full_end  = np.nan
            else:
                inception = df_full[df_full[vol_col] > 0]["time"].min().date().isoformat()
                full_end  = df_full[df_full[vol_col] > 0]["time"].max().date().isoformat()

            rows.append({
                "asset":               name,
                "asset_type":          info["asset_type"],
                "venue":               side,
                "inception_date":      inception,
                "last_date":           full_end,
                "full_n_obs":          len(full_valid),
                "full_mean_vol_usd":   round(float(full_valid.mean()),    0) if len(full_valid) else np.nan,
                "full_median_vol_usd": round(float(full_valid.median()),  0) if len(full_valid) else np.nan,
                "full_std_vol_usd":    round(float(full_valid.std()),     0) if len(full_valid) > 1 else np.nan,
                "full_min_vol_usd":    round(float(full_valid.min()),     0) if len(full_valid) else np.nan,
                "full_max_vol_usd":    round(float(full_valid.max()),     0) if len(full_valid) else np.nan,
                "win_n_obs":           len(win_valid),
                "win_mean_vol_usd":    round(float(win_valid.mean()),     0) if len(win_valid) else np.nan,
                "win_median_vol_usd":  round(float(win_valid.median()),   0) if len(win_valid) else np.nan,
                "win_std_vol_usd":     round(float(win_valid.std()),      0) if len(win_valid) > 1 else np.nan,
            })

    out_df   = pd.DataFrame(rows).sort_values(["asset_type", "asset", "venue"])
    out_path = out_dir / "table1_descriptive_stats.csv"
    out_df.to_csv(out_path, index=False)
    print(f"  → Saved: {out_path}  ({len(out_df)} rows)")
    return out_df


# =============================================================================
# FIGURE 1: DeFi vs TradFi Volume Time Series (3 panels by asset class)
# =============================================================================

def figure1_volume_timeseries(assets):
    """Aggregate daily DeFi and TradFi volume per asset class, analysis window."""
    fig, axes = plt.subplots(3, 1, figsize=(9, 9), sharex=False)
    fig.suptitle(
        "DeFi vs. TradFi Daily Trading Volume by Asset Class\n"
        "(July 2025 – February 2026)",
        fontsize=12, y=1.01
    )

    for ax, asset_type in zip(axes, TYPE_ORDER):
        label        = TYPE_LABELS[asset_type]
        class_assets = [n for n, t in ASSET_TYPES.items() if t == asset_type]

        defi_daily, tradfi_daily = {}, {}
        for name in class_assets:
            df = assets[name]["df"].copy()
            df = df[(df["time"] >= START_TS) & (df["time"] <= END_TS)]
            for _, row in df.iterrows():
                d  = row["time"]
                dv = row["defi_notional_volume"]
                tv = row["tradfi_notional_volume"]
                if pd.notna(dv) and dv > 0:
                    defi_daily[d]   = defi_daily.get(d, 0) + dv
                if pd.notna(tv) and tv > 0:
                    tradfi_daily[d] = tradfi_daily.get(d, 0) + tv

        if not defi_daily and not tradfi_daily:
            ax.set_visible(False)
            continue

        all_dates   = sorted(set(list(defi_daily) + list(tradfi_daily)))
        defi_vals   = [defi_daily.get(d, np.nan)   for d in all_dates]
        tradfi_vals = [tradfi_daily.get(d, np.nan) for d in all_dates]

        ax2 = ax.twinx()
        ax.fill_between(all_dates, defi_vals,   alpha=0.35, color=DEFI_COLOR,   label="DeFi Volume")
        ax.plot(all_dates, defi_vals, color=DEFI_COLOR, lw=1.2)
        ax2.fill_between(all_dates, tradfi_vals, alpha=0.2,  color=TRADFI_COLOR, label="TradFi Volume")
        ax2.plot(all_dates, tradfi_vals, color=TRADFI_COLOR, lw=1.2, ls="--")

        ax.set_title(label, fontsize=10)
        ax.set_ylabel("DeFi Volume (USD)",   color=DEFI_COLOR,   fontsize=9)
        ax2.set_ylabel("TradFi Volume (USD)", color=TRADFI_COLOR, fontsize=9)
        ax.yaxis.set_major_formatter(mticker.FuncFormatter(
            lambda x, _: f"${x/1e9:.1f}B" if x >= 1e9 else f"${x/1e6:.0f}M"
        ))
        ax2.yaxis.set_major_formatter(mticker.FuncFormatter(
            lambda x, _: (f"${x/1e12:.1f}T" if x >= 1e12 else
                          (f"${x/1e9:.1f}B"  if x >= 1e9  else f"${x/1e6:.0f}M"))
        ))
        ax.xaxis.set_major_formatter(mdates.DateFormatter("%b '%y"))
        ax.xaxis.set_major_locator(mdates.MonthLocator())
        plt.setp(ax.xaxis.get_majorticklabels(), rotation=30, ha="right")

        lines1, labels1 = ax.get_legend_handles_labels()
        lines2, labels2 = ax2.get_legend_handles_labels()
        ax.legend(lines1 + lines2, labels1 + labels2, loc="upper left", framealpha=0.7)

        ax.tick_params(axis="y", colors=DEFI_COLOR)
        ax2.tick_params(axis="y", colors=TRADFI_COLOR)
        ax.spines["left"].set_color(DEFI_COLOR)
        ax2.spines["right"].set_color(TRADFI_COLOR)

    plt.tight_layout()
    save_fig(fig, "figure1_volume_time_series")


# =============================================================================
# FIGURE 2: T-score Heatmap (assets × dates)
# =============================================================================

def figure2_tscore_heatmap(ttest_data):
    """Heatmap of DeFi t-scores for all 17 assets over the analysis window."""
    frames = []
    for name, df in ttest_data.items():
        win = df[(df["date"] >= START_TS) & (df["date"] <= END_TS)].copy()
        win = win[["date", "defi_t_score"]].rename(columns={"defi_t_score": name})
        frames.append(win.set_index("date"))

    if not frames:
        print("  [SKIP] No t-test data for heatmap")
        return

    pivot   = pd.concat(frames, axis=1).sort_index()
    ordered = sorted(pivot.columns, key=lambda n: (TYPE_ORDER.index(ASSET_TYPES[n]), n))
    pivot   = pivot[ordered].clip(-15, 15)

    fig, ax = plt.subplots(figsize=(13, 6))
    norm    = TwoSlopeNorm(vmin=-15, vcenter=0, vmax=15)
    im      = ax.pcolormesh(
        pivot.index, np.arange(len(pivot.columns)),
        pivot.T.values, cmap=plt.cm.RdBu_r, norm=norm, shading="auto"
    )

    ax.set_yticks(np.arange(len(pivot.columns)) + 0.5)
    ax.set_yticklabels(pivot.columns, fontsize=8)
    ax.xaxis.set_major_formatter(mdates.DateFormatter("%b '%y"))
    ax.xaxis.set_major_locator(mdates.MonthLocator())
    plt.setp(ax.xaxis.get_majorticklabels(), rotation=30, ha="right")

    cbar = fig.colorbar(im, ax=ax, fraction=0.025, pad=0.01)
    cbar.set_label("DeFi Volume T-Score (clipped ±15)", fontsize=9)

    crypto_end = sum(1 for n in ordered if ASSET_TYPES[n] == "Crypto Coin")
    equity_end = crypto_end + sum(1 for n in ordered if ASSET_TYPES[n] == "Traditional Equity")
    for sep in [crypto_end, equity_end]:
        ax.axhline(sep, color="white", lw=2)

    for atype in TYPE_ORDER:
        indices = [j for j, n in enumerate(ordered) if ASSET_TYPES[n] == atype]
        if indices:
            mid = np.mean(indices) + 0.5
            ax.text(1.01, mid / len(ordered), TYPE_LABELS[atype],
                    transform=ax.transAxes, va="center", rotation=90,
                    fontsize=8, color=NEUTRAL_COLOR)

    ax.set_title("DeFi Volume Anomalies Heatmap (Jul 2025 – Feb 2026)\n"
                 "Color = DeFi T-Score; Red = Spike, Blue = Crash", fontsize=11)
    ax.set_xlabel("Date")
    plt.tight_layout()
    save_fig(fig, "figure2_tscore_heatmap")


# =============================================================================
# FIGURE 3: Event Study (±10 days around each macro event)
# =============================================================================

def figure3_event_study(ttest_data):
    """Average abnormal DeFi and TradFi volume ±10 days around macro events."""
    n_events = len(EVENTS)
    n_cols   = 3
    n_rows   = (n_events + n_cols - 1) // n_cols

    fig, axes = plt.subplots(n_rows, n_cols, figsize=(13, 4 * n_rows),
                              sharey=False, squeeze=False)
    fig.suptitle(
        "Event Study: Average Abnormal Volume Around Major Macro Events\n"
        "(Window = ±10 Days; Dashed Lines = |t| ≥ 4.303 Threshold)",
        fontsize=12
    )

    lags = np.arange(-10, 11)

    for idx, (event_label, event_date_str, target_assets) in enumerate(EVENTS):
        ax       = axes[idx // n_cols][idx % n_cols]
        event_dt = pd.Timestamp(event_date_str)

        defi_lags   = {lag: [] for lag in lags}
        tradfi_lags = {lag: [] for lag in lags}

        for name in target_assets:
            if name not in ttest_data:
                continue
            df = ttest_data[name]
            event_rows = df[df["date"] == event_dt]
            event_idx  = event_rows.index[0] if not event_rows.empty else (df["date"] - event_dt).abs().idxmin()

            for lag in lags:
                target_idx = event_idx + lag
                if 0 <= target_idx < len(df):
                    dt = df.loc[target_idx, "defi_t_score"]
                    tt = df.loc[target_idx, "tradfi_t_score"]
                    if pd.notna(dt):
                        defi_lags[lag].append(dt)
                    if pd.notna(tt):
                        tradfi_lags[lag].append(tt)

        avg_defi   = [np.mean(defi_lags[l])   if defi_lags[l]   else np.nan for l in lags]
        avg_tradfi = [np.mean(tradfi_lags[l]) if tradfi_lags[l] else np.nan for l in lags]

        ax.axhline(0,      color="gray",   lw=0.8)
        ax.axhline( 4.303, color="salmon", lw=0.8, ls="--", alpha=0.7)
        ax.axhline(-4.303, color="salmon", lw=0.8, ls="--", alpha=0.7)
        ax.axvspan(-0.5, 0.5, color="yellow", alpha=0.3, label="Event day")
        ax.plot(lags, avg_defi,   color=DEFI_COLOR,   lw=2,        label="DeFi Avg t")
        ax.plot(lags, avg_tradfi, color=TRADFI_COLOR, lw=2, ls="--", label="TradFi Avg t")

        ax.set_title(f"{event_label}\n({event_date_str})", fontsize=9)
        ax.set_xlabel("Days relative to event", fontsize=8)
        ax.set_ylabel("Avg t-score", fontsize=8)
        ax.set_xticks([-10, -5, 0, 5, 10])
        ax.set_xlim(-10.5, 10.5)
        if idx == 0:
            ax.legend(fontsize=8)

    for idx in range(n_events, n_rows * n_cols):
        axes[idx // n_cols][idx % n_cols].set_visible(False)

    plt.tight_layout()
    save_fig(fig, "figure3_event_study")


# =============================================================================
# FIGURE 4: Cross-Correlation (per asset class)
# =============================================================================

def figure4_cross_correlation():
    """Bar charts of cross-correlation by asset class using DATA-1 output."""
    cc_dir = PHASE4_DIR / "Cross-Correlation"
    lags   = list(range(-7, 8))

    fig, axes = plt.subplots(1, 3, figsize=(13, 4), sharey=True)
    fig.suptitle(
        "Cross-Correlation: DeFi vs. TradFi Volume\n"
        "(Negative lag = DeFi leads TradFi; Positive = TradFi leads DeFi)",
        fontsize=11
    )

    for ax, asset_type in zip(axes, TYPE_ORDER):
        label        = TYPE_LABELS[asset_type]
        class_assets = [n for n, t in ASSET_TYPES.items() if t == asset_type]

        avg_corr = {lag: [] for lag in lags}
        for name in class_assets:
            csv = cc_dir / f"{name}_cross_correlation.csv"
            if not csv.exists():
                continue
            df = pd.read_csv(csv)
            for _, row in df.iterrows():
                lag  = int(row["lag"])
                corr = row["correlation"]
                if pd.notna(corr):
                    avg_corr[lag].append(corr)

        lags_list = sorted(avg_corr)
        means     = [np.mean(avg_corr[l]) if avg_corr[l] else np.nan for l in lags_list]
        stds      = [np.std(avg_corr[l])  if len(avg_corr[l]) > 1 else 0 for l in lags_list]
        colors    = [DEFI_COLOR if l < 0 else TRADFI_COLOR if l > 0 else NEUTRAL_COLOR
                     for l in lags_list]

        ax.bar(lags_list, means, color=colors, alpha=0.75, width=0.7)
        ax.errorbar(lags_list, means, yerr=stds, fmt="none", color="black",
                    capsize=3, lw=1, alpha=0.6)
        ax.axhline(0, color="gray", lw=0.8)
        ax.axvline(0, color="gray", lw=0.8, ls="--", alpha=0.5)
        ax.set_title(label, fontsize=10)
        ax.set_xlabel("Lag (days)", fontsize=9)
        ax.set_xticks(lags)
        ax.set_ylim(-1, 1)

    axes[0].set_ylabel("Avg. Pearson Correlation", fontsize=9)

    legend_elements = [
        Patch(facecolor=DEFI_COLOR,    alpha=0.75, label="DeFi leads (lag < 0)"),
        Patch(facecolor=TRADFI_COLOR,  alpha=0.75, label="TradFi leads (lag > 0)"),
        Patch(facecolor=NEUTRAL_COLOR, alpha=0.75, label="Contemporaneous (lag = 0)"),
    ]
    fig.legend(handles=legend_elements, loc="lower center", ncol=3,
               bbox_to_anchor=(0.5, -0.05), fontsize=9)

    plt.tight_layout()
    save_fig(fig, "figure4_cross_correlation")


# =============================================================================
# FIGURE 5: Price Tracking (scatter DeFi close vs TradFi close)
# =============================================================================

def figure5_price_tracking(assets):
    """Scatter plots of DeFi vs TradFi close prices, one panel per asset class."""
    fig, axes = plt.subplots(1, 3, figsize=(13, 5))
    fig.suptitle(
        "DeFi vs. TradFi Price Tracking Accuracy\n"
        "(Each point = 1 trading day; dashed line = perfect tracking)",
        fontsize=11
    )

    for ax, asset_type in zip(axes, TYPE_ORDER):
        label        = TYPE_LABELS[asset_type]
        class_assets = [n for n, t in ASSET_TYPES.items() if t == asset_type]

        all_x, all_y, asset_corrs = [], [], []
        for i, name in enumerate(class_assets):
            df    = assets[name]["df"]
            valid = df[df["defi_close"].notna() & df["tradfi_close"].notna()].copy()
            if len(valid) < 5:
                continue
            x    = valid["tradfi_close"].values
            y    = valid["defi_close"].values
            corr = float(np.corrcoef(x, y)[0, 1])
            asset_corrs.append(corr)
            ax.scatter(x, y, s=8, alpha=0.5, color=plt.cm.tab10(i % 10),
                       label=f"{name} (ρ={corr:.3f})")
            all_x.extend(x)
            all_y.extend(y)

        if all_x:
            mn, mx = min(min(all_x), min(all_y)), max(max(all_x), max(all_y))
            ax.plot([mn, mx], [mn, mx], "k--", lw=1, alpha=0.5, label="y = x")

        ax.set_xlabel("TradFi Price (USD)", fontsize=9)
        ax.set_ylabel("DeFi Price (USD)",   fontsize=9)
        avg_corr = np.mean(asset_corrs) if asset_corrs else np.nan
        ax.set_title(f"{label}\nAvg ρ = {avg_corr:.4f}", fontsize=10)
        ax.legend(fontsize=7, loc="upper left", markerscale=2)
        ax.xaxis.set_major_formatter(mticker.FuncFormatter(
            lambda x, _: f"${x:,.0f}" if x >= 1 else f"${x:.4f}"
        ))
        ax.yaxis.set_major_formatter(mticker.FuncFormatter(
            lambda x, _: f"${x:,.0f}" if x >= 1 else f"${x:.4f}"
        ))

    plt.tight_layout()
    save_fig(fig, "figure5_price_tracking")


# =============================================================================
# FIGURE 6: Cross-Asset Breadth Timeline
# =============================================================================

def figure6_breadth_timeline():
    """Time series of number of simultaneous volume anomalies per date."""
    breadth_csv = DATES_DIR / "dates_breadth_summary.csv"
    if not breadth_csv.exists():
        print("  [SKIP] dates_breadth_summary.csv not found")
        return

    df = pd.read_csv(breadth_csv, parse_dates=["date"])
    df = df.sort_values("date")
    df = df[(df["date"] >= "2025-06-01") & (df["date"] <= "2026-02-28")]

    fig, ax = plt.subplots(figsize=(12, 5))
    ax.bar(df["date"], df["num_both"],       color=NEUTRAL_COLOR,    label="Both DeFi+TradFi significant", alpha=0.85)
    ax.bar(df["date"], df["num_defi_only"],  bottom=df["num_both"],  color=DEFI_COLOR,   label="DeFi-only significant", alpha=0.7)
    ax.bar(df["date"], df["num_tradfi_only"],
           bottom=df["num_both"] + df["num_defi_only"],              color=TRADFI_COLOR, label="TradFi-only significant", alpha=0.7)

    top5 = df.nlargest(5, "num_assets_significant")
    for _, row in top5.iterrows():
        ax.annotate(
            f"{row['num_assets_significant']}",
            xy=(row["date"], row["num_assets_significant"]),
            xytext=(0, 4), textcoords="offset points",
            ha="center", fontsize=8, color="black",
        )

    ymax = df["num_assets_significant"].max()
    for date_str, label in [("2025-10-10", "Tariff\nShock"), ("2026-01-27", "DeepSeek"),
                              ("2026-01-29", "FOMC+\nEarnings"), ("2026-01-30", "Warsh\nShock")]:
        dt = pd.Timestamp(date_str)
        if df["date"].min() <= dt <= df["date"].max():
            ax.axvline(dt, color="orange", lw=1.2, ls="--", alpha=0.8)
            ax.text(dt, ymax * 0.92, label, ha="center", fontsize=7,
                    color="darkorange", va="top")

    ax.set_xlabel("Date")
    ax.set_ylabel("Number of Assets with Significant Volume Anomaly")
    ax.set_title(
        "Cross-Asset Breadth of Volume Anomalies (Jul 2025 – Feb 2026)\n"
        "Stacked: Both-Significant / DeFi-Only / TradFi-Only",
        fontsize=11
    )
    ax.xaxis.set_major_formatter(mdates.DateFormatter("%b '%y"))
    ax.xaxis.set_major_locator(mdates.MonthLocator())
    plt.setp(ax.xaxis.get_majorticklabels(), rotation=30, ha="right")
    ax.legend(loc="upper left", fontsize=9)
    ax.set_ylim(0, ymax + 2)

    plt.tight_layout()
    save_fig(fig, "figure6_breadth_timeline")


# =============================================================================
# FIGURE 7: Funding Rate Snapshot (bar chart)
# =============================================================================

def figure7_funding_rates():
    """Bar chart of annualised funding rates for all 17 assets (snapshot)."""
    fr_csv = PHASE4_DIR / "Funding-Rate-Analysis" / "funding_rate_summary.csv"
    if not fr_csv.exists():
        print("  [SKIP] funding_rate_summary.csv not found — run DATA-4 first")
        return

    df = pd.read_csv(fr_csv)
    df = df.sort_values(["asset_type", "funding_annualised_pct"], ascending=[True, False])

    color_map = {
        "Crypto Coin":           DEFI_COLOR,
        "Traditional Equity":    TRADFI_COLOR,
        "Traditional Commodity": COMMODITY_COLOR,
    }
    colors = [color_map[at] for at in df["asset_type"]]

    fig, ax = plt.subplots(figsize=(12, 5))
    bars = ax.bar(df["asset"], df["funding_annualised_pct"],
                  color=colors, alpha=0.8, edgecolor="white", lw=0.5)
    ax.axhline(0, color="gray", lw=1)

    for bar, val in zip(bars, df["funding_annualised_pct"]):
        if pd.notna(val):
            y_pos = val + (0.3 if val >= 0 else -0.6)
            ax.text(bar.get_x() + bar.get_width() / 2, y_pos,
                    f"{val:.2f}%", ha="center", va="bottom", fontsize=7, rotation=90)

    ax.set_xlabel("Asset")
    ax.set_ylabel("Annualised Funding Rate (%)")
    ax.set_title(
        "Snapshot Funding Rates Across DeFi Perpetuals (Annualised)\n"
        "Positive = Longs pay shorts (net bullish positioning)",
        fontsize=11
    )
    plt.setp(ax.xaxis.get_majorticklabels(), rotation=45, ha="right")

    legend_elements = [
        Patch(facecolor=DEFI_COLOR,      label="Crypto Coins"),
        Patch(facecolor=TRADFI_COLOR,    label="Tokenized Equities"),
        Patch(facecolor=COMMODITY_COLOR, label="Tokenized Commodities"),
    ]
    ax.legend(handles=legend_elements, loc="upper right", fontsize=9)

    plt.tight_layout()
    save_fig(fig, "figure7_funding_rates")


# =============================================================================
# FIGURE 8: Volume Ratio Bar Chart (TradFi / DeFi, ranked)
# =============================================================================

def figure8_volume_ratios():
    """Ranked bar chart of TradFi/DeFi mean volume ratio (analysis window)."""
    ratio_csv = PHASE4_DIR / "Volume-Ratios" / "volume_ratios.csv"
    if not ratio_csv.exists():
        print("  [SKIP] volume_ratios.csv not found — run DATA-3 first")
        return

    df = pd.read_csv(ratio_csv)
    df["ratio"] = df["win_tradfi_defi_ratio"].combine_first(df["full_tradfi_defi_ratio"])
    df = df.dropna(subset=["ratio"]).sort_values("ratio", ascending=False)

    color_map = {
        "Crypto Coin":           DEFI_COLOR,
        "Traditional Equity":    TRADFI_COLOR,
        "Traditional Commodity": COMMODITY_COLOR,
    }
    colors = [color_map[at] for at in df["asset_type"]]

    fig, ax = plt.subplots(figsize=(12, 5))
    bars = ax.bar(df["asset"], df["ratio"], color=colors, alpha=0.8,
                  edgecolor="white", lw=0.5, log=True)
    ax.axhline(1, color="gray", lw=1, ls="--", alpha=0.7, label="1:1 parity")

    for bar, val in zip(bars, df["ratio"]):
        ax.text(bar.get_x() + bar.get_width() / 2,
                bar.get_height() * 1.15,
                f"{val:.1f}x", ha="center", va="bottom", fontsize=7)

    ax.set_xlabel("Asset")
    ax.set_ylabel("TradFi / DeFi Mean Daily Volume Ratio (log scale)")
    ax.set_title(
        "TradFi vs. DeFi Daily Volume Scale (Jul 2025 – Feb 2026)\n"
        "Ratio > 1 = TradFi larger; Ratio < 1 = DeFi larger",
        fontsize=11
    )
    plt.setp(ax.xaxis.get_majorticklabels(), rotation=45, ha="right")

    legend_elements = [
        Patch(facecolor=DEFI_COLOR,      label="Crypto Coins"),
        Patch(facecolor=TRADFI_COLOR,    label="Tokenized Equities"),
        Patch(facecolor=COMMODITY_COLOR, label="Tokenized Commodities"),
        plt.Line2D([0], [0], color="gray", ls="--", lw=1, label="1:1 parity"),
    ]
    ax.legend(handles=legend_elements, loc="upper right", fontsize=9)

    plt.tight_layout()
    save_fig(fig, "figure8_volume_ratios")


# =============================================================================
# MAIN
# =============================================================================

if __name__ == "__main__":
    # ── DATA analyses ─────────────────────────────────────────────────────────
    print("=" * 70)
    print("Loading Phase 1B assets …")
    print("=" * 70)
    assets = load_assets()
    print(f"\nLoaded {len(assets)} assets.\n")

    print("=" * 70)
    print("DATA-1: Cross-Correlation Analysis")
    print("=" * 70)
    run_cross_correlation(assets)

    print("\n" + "=" * 70)
    print("DATA-2: Price Tracking Accuracy")
    print("=" * 70)
    run_price_tracking(assets)

    print("\n" + "=" * 70)
    print("DATA-3: Volume Ratios (TradFi / DeFi)")
    print("=" * 70)
    run_volume_ratios(assets)

    print("\n" + "=" * 70)
    print("DATA-4: Funding Rate Analysis")
    print("=" * 70)
    run_funding_rate_analysis()

    print("\n" + "=" * 70)
    print("DATA-5: Table 1 Descriptive Statistics")
    print("=" * 70)
    run_table1(assets)

    # ── Figures ───────────────────────────────────────────────────────────────
    print("\n" + "=" * 70)
    print("Loading t-test data (Phase 2B) …")
    print("=" * 70)
    ttest_data = load_ttest_csvs()
    print(f"  {len(ttest_data)} t-test files loaded\n")

    print("=" * 70)
    print("Generating Figures …")
    print("=" * 70)

    print("Figure 1: Volume time series …")
    figure1_volume_timeseries(assets)

    print("Figure 2: T-score heatmap …")
    figure2_tscore_heatmap(ttest_data)

    print("Figure 3: Event study …")
    figure3_event_study(ttest_data)

    print("Figure 4: Cross-correlation …")
    figure4_cross_correlation()

    print("Figure 5: Price tracking …")
    figure5_price_tracking(assets)

    print("Figure 6: Breadth timeline …")
    figure6_breadth_timeline()

    print("Figure 7: Funding rates …")
    figure7_funding_rates()

    print("Figure 8: Volume ratios …")
    figure8_volume_ratios()

    print("\n" + "=" * 70)
    print(f"All outputs saved under: {PHASE4_DIR.resolve()}")
    print("=" * 70)
